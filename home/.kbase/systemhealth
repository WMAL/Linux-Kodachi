#!/bin/bash
# Script written by Warith Al Maawali  
# (c) 2019 Founder of Eagle Eye Digital Solutions
# http://www.digi77.com
# http://www.om77.net
# script starts here:

# Testing and examples
#sudo -H -u kodachi bash -c 'echo $HOME' > $Myhome_path/Desktop/t.txt

#Cheatsheet:

 #-eq # equal
#-ne # not equal
#-lt # less than
#-le # less than or equal
#-gt # greater than
#-ge # greater than or equal


#A; B    # Run A and then B, regardless of success of A
#A && B  # Run B if and only if A succeeded
#A || B  # Run B if and only if A failed
#A &     # Run A in background.

# Pass output and excute it examples
# cat workingdomain.txt |xargs -n1 curl -t 15
# find /path -type f | while read ln; do echo "processing $ln"; done
# echo "input" | awk '{print $1"string"}



#nolapic
#noapic
#acpi_osi=“Linux”
#acpi_osi=“Windows 2006”
#acpi=ht
#pci=noacpi
#acpi=noirq
#pnpacpi=off
#acpi=off

#apt stuff
#sudo apt-get purge --auto-remove thermald
#sudo apt rdepends thermald

#cheat sheet
#sudo kill -9 `ps -ef | grep hardworknet | grep -v grep | awk '{print $2}'`
#sudo bash systemhealth -a hardworknet


#sudo kill -9 `ps -ef | grep hardworknonet | grep -v grep | awk '{print $2}'`
#sudo bash systemhealth -a hardworknonet


#sudo kill -9 `ps -ef | grep reschangecheck | grep -v grep | awk '{print $2}'`
#sudo bash reschangecheck




cd $(dirname $0) 
source Globalconfig;



# Set global;
unset e;
unset IP_ADDR;
unset TIP_ADDR;
unset IP_ADDRPublic;
unset originalIP;
unset theCountry;
unset theCountryx;
kodachi_version=$Kodachi_version;
netIP='google.com';
unset randomdomain;
vpntype="kodachivpn";
sameipCounter=0;
killVPNTorcounterpopup=0;
tornullipcounter=0;
# Hay don't cheat leave this value alone :p
securityScore=0;
fileDomain1="$Mykodachi_path/workingdomain.txt";
fileDomain2="$Mykodachi_path/workingdomaintmp.txt";

 


# If no su privileges available, try to get them
if [[ ! "$(whoami)" == "root" ]] ; then
	
	# No sudo available? Then we can't get su privs. Advise and exit
	if [[ $(which sudo) == "" ]] ; then
		echo "'sudo' package missing! Please install."
		echo "e.g.: apt-get install sudo" 
		exit 1
	fi

	echo "Requesting su permissions..."
	# Run this script with sudo privs
	sudo $0 $*
		# If running this script with su privs failed, advise to do so manually and exit
		if [[ $? > 0 ]] ; then
		echo
		echo "Acquiring su permission failed!"
		echo "Please run this script with sudo permissions!"
		echo "(e.g. 'sudo $0' or 'sudo bash $0')"
		echo
		exit 1
	fi
exit 0
fi


 
 

# detect empty arguments
if [ $# -eq 0 ]; then
	echo "No arguments entered"
	
	#pause 'Press [Enter] key to exit...or Ctrl c to quit the script and run it again correctly'	
        #exit 1
fi


# Accept command line arguments
while [ $# -gt 0 ]
do
    case "$1" in
    -a)  myAction=$2 ; shift;;       
	--)	shift; break;;
	-*)
	    echo >&2 \
	    "usage: $0 [-v] [-f file] [file ...]"
	    exit 1;;
	*)  break;;	# terminate while loop
    esac
    shift
done



 
#Set of functions
function getID()
{
       
    a=$(sudo dmidecode -s system-uuid);
	b=$(sudo dmidecode -s system-serial-number);
	c=$(sudo dmidecode |grep -w ID:|head -n1);
	m=$a.$b.$c;
	e=$(md5sum <<<$m| tr -d -|tr -d ' ');
    echo $e | cut -d ' ' -f 1 > $Mykodachi_path/HWID;
       
}

function getMem()
{
	echo " Inside memory function";
	hw_mem=0
	free_mem=0
	human=1024
	mem_info=$(</proc/meminfo)
	mem_info=$(echo $(echo $(mem_info=${mem_info// /}; echo ${mem_info//kB/})))
		
	for m in $mem_info; do
		if [[ ${m//:*} = MemTotal ]]; then
			memtotal=${m//*:}
		fi

		if [[ ${m//:*} = MemFree ]]; then
			memfree=${m//*:}
		fi

		if [[ ${m//:*} = Buffers ]]; then
			membuffer=${m//*:}
		fi

		if [[ ${m//:*} = Cached ]]; then
			memcached=${m//*:}
		fi			
	done

	usedmem="$(((($memtotal - $memfree) - $membuffer - $memcached) / $human))"
	totalmem="$(($memtotal / $human))"
	mem="${usedmem}M / ${totalmem}M"
	echo $mem > $Mykodachi_path/Memused;
	echo "Mem details: "$mem;
	
	
}	


function getBan()
{
    getID
    #Banned Stuff
    Ban_Status=$(sudo curl -G -s -m 30 "https://www.digi77.com/software/vpn/ko_band_check.php" --data-urlencode "ko_hwid=$e" --data-urlencode "ko_ver=$kodachi_version");
    echo $Ban_Status | cut -d ' ' -f 1 > $Mykodachi_path/BandSatus;
    echo "getBan: Kodachi status:" $Ban_Status;
}

function banAction()
{
    
    SERVICE='openvpn';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then
		sudo killall -SIGINT openvpn;
	fi
    sudo killall tor; 
    unset TIP_ADDR; 
    cat $Mykodachi_path/dns/dns4 > $Mykodachi_path/dns/dns1;
	sudo bash -c 'cat dns/dns4 > /etc/resolv.conf'; 
	echo "0" > $Mykodachi_path/dns/autodnscrypt;
	echo "0" > $Mykodachi_path/torenabled;
	echo "Disabled" > $Mykodachi_path/vpntype;
	sudo service dnscrypt-proxy stop  
	
	
    #only if run by system cron  
    #export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/notify-send Sorry! "You have been banned from our network please contact support@digi77.com"
    #export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/conky -c $Mykodachi_path/.conkyrc4;
    
    notify-send -i $notifyIcon  "You have been banned from $OS_name VPN network please contact support@digi77.com"
	
    
}


function getVersion()
{
   KO_Version=$(sudo curl -s -m 30 https://www.digi77.com/software/kodachi/version|cut -d , -f 2)
	echo "getVersion: Kodachi Net Version is: @$KO_Version@  System version: @$kodachi_version@";
	echo -n $KO_Version > $Mykodachi_path/version;

	if [ -n "$KO_Version" ]  
		then
		if [[ "$KO_Version" != *$kodachi_version* ]]
		then
			    
			#only if run by system cron
			#export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/conky -c $Mykodachi_path/.conkyrc5;
			echo "!" > $Mykodachi_path/newversionalert;	
			echo "version no match";	
			sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/newversionalert;	
				
		else
			rm -f $Mykodachi_path/newversionalert;	
			echo "version match";
			
		fi	
	fi 
	
}

function checkDNSisRunning()
{
	dnsstatus=$(cat $Mykodachi_path/dns/autodnscrypt);
	SERVICE='dnscrypt-proxy';
	if [[ "$dnsstatus" == 1 ]]
	then
		echo "autodnscrypt status is : $dnsstatus";
		#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
		if ! systemctl is-active dnscrypt-proxy.service > /dev/null 2>&1; 
		then
			echo "No DNS Crypt process Starting Dnscrypt";
			sudo service dnscrypt-proxy stop    
			sudo service dnscrypt-proxy start			
			sudo bash -c 'cat dns/dns0 > /etc/resolv.conf';			
		else
			echo "Dnscrypt running no issue";
		fi
	fi
	
	
	
	
	if (grep -R Tor $Mykodachi_dns_path/dns1)
	then			 
		SERVICE='tor-service';
		#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
		if ! systemctl is-active tor.service > /dev/null 2>&1;  
		then	
			notify-send -i $notifyIcon "Restarting Tor it was shutdown and you are using Tor DNS";
			sudo bash $Mykodachi_dns_path/.tordns;			
		fi
	fi
	
	
	
	
}


function resetips()
{
	unset IP_ADDRPublic;
	unset TIP_ADDR;
	unset theCountry;
	unset theCountryx;
	
	echo "-" > $Mykodachi_path/.eeds-ipinfo;
	echo "-" > $Mykodachi_path/.eeds-tipinfo;
	
	SERVICE='openvpn';
    if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
    then
		unset originalIP;
		echo "-" > $Mykodachi_path/.eeds-oipinfo;
		echo "-" > $Mykodachi_path/.eeds-ocipinfo;
    fi
	
}

function startvpnfunction()
{
   
    vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
    # make sure we have internet before starting    
    #ping -c 1 -W 2 "$netIP" &> /dev/null
    
    torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
	if [[ "$torifySystem" == *Yes* ]]
	then
    	# slow network
    	wget --timeout=15 --waitretry=0 --tries=3 --retry-connrefused -q --spider $netIP &> /dev/null
	else
		wget --timeout=5 --waitretry=0 --tries=3 --retry-connrefused -q --spider $netIP &> /dev/null
	fi
	if [ $? -eq 0 ]; 
	then
		
		
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
		if [[ "$torifySystem" == *Yes* ]]
		then
			notify-send -i $notifyIcon "VPN over Tor  (ISP > TOR > VPN) is considered to be dangerous please disable system toriffy
Before connecting to VPN then check Kodachi website for more information about this";
		fi
		
		if [[ "$vpntype" == *Kodachi* ]]
		then
			notify-send -i $notifyIcon "Kodachi VPN will start now"
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				echo "#### Will kill vpn now before starting it ####";
				sudo killall -SIGINT openvpn;			    
			
			fi	
					 
		
			getID;
			sudo echo -n "kodachi|" > /etc/openvpn/auth
			sudo echo $e | cut -d ' ' -f 1 >> /etc/openvpn/auth;	
			sudo echo "cf90b117a31e7c2bb53cac3186b867b0" >> /etc/openvpn/auth;	
			if(sudo timeout 60 wget "https://digi77.com/software/kodachi/kodachi-vpn.zip" -q)
			then
				sudo rm -f /etc/openvpn/kodachi-vpn.ovpn
				unzip -P a30@06e61-79-34-88-A4-C3@ kodachi-vpn.zip -d /etc/openvpn/
				rm -f kodachi-vpn.zip
				 
			
				#Get proto  port ip
				theOvfile="/etc/openvpn/kodachi-vpn.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					sudo openvpn --daemon --config /etc/openvpn/kodachi-vpn.ovpn > /dev/null 2>&1
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Kodachi VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=kodachi-vpn.ovpn";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "$OS_name VPN Process Done";
					resetips;
				
				else
					theTime=$(date +%H:%M);
					notify-send -i $notifyIcon "$OS_name VPN skipping offline node:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")";
					
				fi
				sudo rm -f /etc/openvpn/kodachi-vpn.ovpn;
				sudo rm -f /etc/openvpn/auth;					
			else
				notify-send -i $notifyIcon "Failed to download $OS_name VPN";
			fi
		fi # end kodachi vpn
		
		
		
		
		
		if [[ "$vpntype" == *Gate* ]]
		then
			# get variables from config
			source $VPN_configs_path/vpngatesetup
			if [[ $randomnvpngate==0 ]] || [[ $randomnvpngate==1 ]]   
			then
		
				notify-send -i $notifyIcon "VPN Gate will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
							 
			
				if [[ "$randomnvpngate" == 1 ]]
				then
				
					randomvpngatepick=$(ls $VPN_gate_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for VPN Gate:$randomvpngatepick";
				else
					randomvpngatepick=$vpngateprofilenametouse;
					echo "User has selected profile for VPN Gate:$randomvpngatepick";
					if [[ ! -f "$VPN_gate_ovpn_dir/$randomvpngatepick" ]] || [[ ! -n "$randomvpngatepick" ]];  
					then
						notify-send -i $notifyIcon "VPN Gate profile $randomvpngatepick is missing correct the vpngatesetup file:" \ "$VPN_configs_path/vpngatesetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_gate_ovpn_dir/$randomvpngatepick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					sudo openvpn --daemon --config $VPN_gate_ovpn_dir/$randomvpngatepick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "VPN Gate will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomvpngatepick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "VPNGATE VPN Process Done";
					resetips;
				
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "VPN Gate skipping offline node:" "$(echo -e "Profile: $randomvpngatepick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")"; 
					
				fi
			else
				notify-send -i $notifyIcon "VPN Gate needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/vpngatesetup;			   	
			
			fi
			 
		fi	# end vpngate
		
		
		
		
		
		if [[ "$vpntype" == *Kern* ]]
		then
			# get variables from config
			source $VPN_configs_path/kernvpnsetup
			if [[ $randomkernvpn==0 ]] || [[ $randomkernvpn==1 ]]   
			then
		
				notify-send -i $notifyIcon "Kern VPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
							 
			
				if [[ "$randomkernvpn" == 1 ]]
				then
				
					randomkernvpnpick=$(ls $VPN_kern_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Kern VPN:$randomkernvpnpick";
				else
					randomkernvpnpick=$kernvpnfilenameuse;
					echo "User has selected profile for Kern VPN:$randomkernvpnpick";
					if [[ ! -f "$VPN_kern_ovpn_dir/$randomkernvpnpick" ]] || [[ ! -n "$randomkernvpnpick" ]];  
					then
						notify-send -i $notifyIcon "Kern VPN profile $randomkernvpnpick is missing correct the kernvpnsetup file:" \ "$VPN_configs_path/kernvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_kern_ovpn_dir/$randomkernvpnpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					sudo openvpn --daemon --config $VPN_kern_ovpn_dir/$randomkernvpnpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Kern VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomkernvpnpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "Kern VPN Process Done";
					resetips;
				
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Kern VPN skipping offline node:" "$(echo -e "Profile: $randomkernvpnpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")"; 
					
				fi
			else
				notify-send -i $notifyIcon "Kern VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/kernvpnsetup;			   	
			
			fi
			 
		fi	# end Kernvpn	
		
		
			 
		
		 
	
		if [[ "$vpntype" == *Nord* ]]
		then
			# get variables from config
			source $VPN_configs_path/nordvpnsetup
			
			if [[ -n "$NordVPNusername" ]] ||  [[  -n "$NordVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "Nord VPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randomnordvpn" == 1 ]]
				then
				
					randomNordpick=$(ls $VPN_nord_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Nord VPN:$randomNordpick";
				else
					randomNordpick=$nordprofilenametouse;
					echo "User has selected profile for Nord VPN:$randomNordpick";
					if [[ ! -f "$VPN_nord_ovpn_dir/$randomNordpick" ]] || [[ ! -n "$randomNordpick" ]];  
					then
						notify-send -i $notifyIcon "Nord VPN profile $randomNordpick is missing correct the nordvpnsetup file:" \ "$VPN_configs_path/nordvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_nord_ovpn_dir/$randomNordpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n'
					echo "$NordVPNusername$NEWLINE$NordVPNpassword" > $VPN_configs_path/nordvpnauth.txt
					sudo openvpn --daemon --config $VPN_nord_ovpn_dir/$randomNordpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Nord VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomNordpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "NORDVPN Process Done";
				    rm -f $VPN_configs_path/nordvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Nord VPN skipping offline node:" "$(echo -e "Profile: $randomNordpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")"; 
					 	
				fi
			else
				notify-send -i $notifyIcon "Nord VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/nordvpnsetup;			   	
			
			fi
			 
		fi	# end nordvpn	 	
		
		
		
		
		if [[ "$vpntype" == *Hideme* ]]
		then
			# get variables from config
			source $VPN_configs_path/hidemevpnsetup
			
			if [[ -n "$HidemeVPNusername" ]] ||  [[  -n "$HidemeVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "Hideme VPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randomhidemevpn" == 1 ]]
				then
				
					randomhidemepick=$(ls $VPN_hideme_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Hideme VPN:$randomhidemepick";
				else
					randomhidemepick=$hidemeprofilenametouse;
					echo "User has selected profile for Hideme VPN:$randomhidemepick";
					if [[ ! -f "$VPN_hideme_ovpn_dir/$randomhidemepick" ]] || [[ ! -n "$randomhidemepick" ]];  
					then
						notify-send -i $notifyIcon "Hideme VPN profile $randomhidemepick is missing correct the hidemevpnsetup file:" \ "$VPN_configs_path/hidemevpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_hideme_ovpn_dir/$randomhidemepick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n';
					echo "$HidemeVPNusername$NEWLINE$HidemeVPNpassword" > $VPN_configs_path/hidemevpnauth.txt
					sudo openvpn --daemon --config $VPN_hideme_ovpn_dir/$randomhidemepick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Hideme VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomhidemepick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "HideMe Process Done"
				    rm -f $VPN_configs_path/hidemevpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Hideme VPN skipping offline node:" "$(echo -e "Profile: $randomhidemepick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" ;
					 	
				fi
			else
				notify-send -i $notifyIcon "Hideme VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/hidemevpnsetup;			   	
			
			fi
			 
		fi	# end hidemevpn	 	
		
		
		
		if [[ "$vpntype" == *Proton* ]]
		then
			# get variables from config
			source $VPN_configs_path/protonvpnsetup
			
			if [[ -n "$ProtonVPNusername" ]] ||  [[  -n "$ProtonVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "Proton VPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randomprotonvpn" == 1 ]]
				then
				
					if [[ "$protonfree" == 1 ]]
					then
						randomprotonpick=$(ls $VPN_proton_ovpn_dir |grep free |sort -R|shuf -n 1);
						echo "Pickced up random free profile for Proton VPN:$randomprotonpick";
					else
						randomprotonpick=$(ls $VPN_proton_ovpn_dir |grep -v free |sort -R|shuf -n 1);
						echo "Pickced up random profile for Proton VPN:$randomprotonpick";
					fi
				else
					randomprotonpick=$protonprofilenametouse;
					echo "User has selected profile for Proton VPN:$randomprotonpick";
					if [[ ! -f "$VPN_proton_ovpn_dir/$randomprotonpick" ]] || [[ ! -n "$randomprotonpick" ]];  
					then
						notify-send -i $notifyIcon "Proton VPN profile $randomprotonpick is missing correct the protonvpnsetup file:" \ "$VPN_configs_path/protonvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_proton_ovpn_dir/$randomprotonpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|head -n 1|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n';
					echo "$ProtonVPNusername$NEWLINE$ProtonVPNpassword" > $VPN_configs_path/protonvpnauth.txt
					sudo openvpn --daemon --config $VPN_proton_ovpn_dir/$randomprotonpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Proton VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomprotonpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "Proton Process Done"
				    rm -f $VPN_configs_path/protonvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Proton VPN skipping offline node:" "$(echo -e "Profile: $randomprotonpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")"; 
					 	
				fi
			else
				notify-send -i $notifyIcon "Proton VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/protonvpnsetup;			   	
			
			fi
			 
		fi	# end protonvpn	 
		
		
		
		
		
		if [[ "$vpntype" == *Mullvad* ]]
		then
			# get variables from config
			source $VPN_configs_path/mullvadvpnsetup
			
			if [[ -n "$MullvadVPNusername" ]] ||  [[  -n "$MullvadVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "Mullvad VPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randommullvadvpn" == 1 ]]
				then
				
					randommullvadpick=$(ls $VPN_mullvad_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Mullvad VPN:$randommullvadpick";
				else
					randommullvadpick=$mullvadprofilenametouse;
					echo "User has selected profile for Mullvad VPN:$randommullvadpick";
					if [[ ! -f "$VPN_mullvad_ovpn_dir/$randommullvadpick" ]] || [[ ! -n "$randommullvadpick" ]];  
					then
						notify-send -i $notifyIcon "Mullvad VPN profile $randommullvadpick is missing correct the mullvadvpnsetup file:" \ "$VPN_configs_path/mullvadvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_mullvad_ovpn_dir/$randommullvadpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n';
					echo "$MullvadVPNusername$NEWLINE$MullvadVPNpassword" > $VPN_configs_path/mullvadvpnauth.txt
					sudo openvpn --daemon --config $VPN_mullvad_ovpn_dir/$randommullvadpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Mullvad VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randommullvadpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "Mullvad Process Done"
				    rm -f $VPN_configs_path/mullvadvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Mullvad VPN skipping offline node:" "$(echo -e "Profile: $randommullvadpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" ;
					 	
				fi
			else
				notify-send -i $notifyIcon "Mullvad VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/mullvadvpnsetup;			   	
			
			fi
			 
		fi	# end mullvadvpn	 		
		
		
		
		
		if [[ "$vpntype" == *Own* ]]
		then
			source $VPN_configs_path/myownvpnsetup			
			if grep "dev tun" $VPN_configs_path/myownvpn.ovpn > /dev/null		 
			then
		
				notify-send -i $notifyIcon "Own VPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
 
			
				#Get proto  port ip
				theOvfile="$VPN_configs_path/myownvpn.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$theVPNipUsed -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$theVPNipUsed -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 						
				fi				
				
				if [[ "$torifySystem" == *No* ]]
				then
					ping -c 1 -W 2 "$theVPNipUsed" &> /dev/null
				else
					return 0;
				fi	
				if [ $? -eq 0 ]; 
				then
					if [[ "$need_user_password" == 1 ]]
					then
						NEWLINE=$'\n';
						echo "$ownvpnusername$NEWLINE$ownvpnpassword" > $VPN_configs_path/myownvpnauth.txt ;
					fi
					sudo openvpn --daemon --config $VPN_configs_path/myownvpn.ovpn > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
					notify-send -t 30000 -i $notifyIcon "Own VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=myownvpn.ovpn";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "Own VPN Process Done"
				    rm -f $VPN_configs_path/myownvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Own VPN skipping offline node:" "$(echo -e "Profile: $randomprotonpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")"; 
				
				fi
			else
				notify-send -i $notifyIcon "Own VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/myownvpn.ovpn;	
				gedit $VPN_configs_path/myownvpnsetup;			   	
			
			fi
			 
		fi	# end Ownvpn
			  
		 
	
		# Auto start and stop tor
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
		if [[ "$autotorvpn" == *1* ]] || [[ "$autotornovpn" == *1* ]] # || [[ "$torifySystem" == *Yes* ]] # don't do it !
		then
			
			
			echo "tor is set to autotorvpn:$autotorvpn";
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				
				sleep 30;
				echo "Sleeping for 30 second before restarting tor after vpn start";
				echo "restart tor after vpn restart";
				echo "check point tor stop 6";
				sudo /etc/init.d/tor restart;
				unset TIP_ADDR;
				tornullipcounter=0;
						
			
			fi
				
		fi
		
		
	
	
	
	else
		echo "No Net we can't start vpns";
	fi
}







function fetchNormalIP()
{ 
	unset theCountry;
	unset IP_ADDRPublic;
	if [ ! -n $randomdomain ]
	then
		echo " Random domain was empty so we set digi77 domain";
		randomdomain="https://www.digi77.com/software/vpn/ipcheckplain.php";
	fi
	
	# Format sample 95.174.64.202:[secure]:Germany
	IP_ADDRPublic=$(sudo curl -s -m 30 $randomdomain )	
	# Remove empty space
	IP_ADDRPublic=$(echo $IP_ADDRPublic|sed 's/ //g'|xargs);
	IP_ADDRPublic=$(echo $IP_ADDRPublic|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
	
	
	
	if [ -n $IP_ADDRPublic ]     
	then 
		theCountry=$(geoiplookup $IP_ADDRPublic|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//');	
		if [[ "$theCountry" == *"not found"* ]]
		then
		    echo "Going to get country online iplocate.io for normal ip:$theCountry";
			theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
			
			if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
			then
				echo "Going to get country online ip2c.org for normal ip:$theCountry";
				theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
				if [[ ! -n $theCountry ]]
				then
					theCountry=$(curl -s -m 20 https://am.i.mullvad.net/country);
				fi
			fi 							
					
		fi				
	 
	
	
	
		SERVICE='openvpn';
		if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
			echo $IP_ADDRPublic":[notsecure]:"$theCountry> $Mykodachi_path/.eeds-ipinfo;
			echo "The Normal ip:"$IP_ADDRPublic":[notsecure]"$theCountry;
			originalIP=$IP_ADDRPublic;
			echo "No2:$originalIP == $IP_ADDRPublic";
			echo $originalIP > $Mykodachi_path/.eeds-oipinfo;
			echo $theCountry > $Mykodachi_path/.eeds-ocipinfo;
		fi
	
	fi 	# Only if ip is found
	
	#echo " Entering fetchNormalIP function";
	SERVICE='openvpn';
    if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
    then
        if [[ "$vpntype" == *Own* ]] ||  [[ "$vpntype" == *Kodachi* ]]  ||  [[ "$vpntype" == *Nord* ]]  || [[ "$vpntype" == *Gate* ]] || [[ "$vpntype" == *Kern* ]] || [[ "$vpntype" == *Hideme* ]] || [[ "$vpntype" == *Proton* ]] || [[ "$vpntype" == *Mullvad* ]]
		then
			#IP_ADDRPublic=$(echo $IP_ADDRPublic|sed 's/ //g'|xargs);
			originalIP=$(echo $originalIP | xargs);			 
			if [ -n "$IP_ADDRPublic" ] 
			then
				if [ "$IP_ADDRPublic" != "$originalIP" ] ; then 					
					echo $IP_ADDRPublic":[secure]:"$theCountry > $Mykodachi_path/.eeds-ipinfo;
					echo "The Normal ip:"$IP_ADDRPublic":[secure]"$theCountry;
					echo "$originalIP != $IP_ADDRPublic";				
				else				
					torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
					if [[ "$torifySystem" == *No* ]]
					then
						echo $IP_ADDRPublic":[notsecure]:"$theCountry> $Mykodachi_path/.eeds-ipinfo;
						echo "The Normal ip:"$IP_ADDRPublic":[notsecure]"$theCountry;
						echo "No1:$originalIP == $IP_ADDRPublic";
					else
						echo $IP_ADDRPublic":[secure]:"$theCountry > $Mykodachi_path/.eeds-ipinfo;
						echo "The Normal ip:"$IP_ADDRPublic":[secure]"$theCountry;
						echo "$originalIP != $IP_ADDRPublic";			
					
					fi
				fi
			fi
        fi
    fi 
    
    #Refrence update ip DB
    #cd /usr/share/geoip
	#wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz || { echo 'Could not download GeoLiteCountry, exiting.' ; exit 1; }
	#wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz || { echo 'Could not download GeoLiteCity, exiting.' ; exit 1; }
	#gunzip -f GeoIP.dat.gz
	#gunzip -f GeoLiteCity.dat.gz
	#echo "y"|mv GeoLiteCity.dat GeoIPCity.dat
	
}

function fetchKodachiIP ()
{ 
	SERVICE='openvpn';
    if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
    then
		getID
		IP_ADDR=$(sudo curl -G -s -m 30 "https://www.digi77.com/software/vpn/ipcheckplain.php"  --data-urlencode "ko_hwid=$e" --data-urlencode "ko_ver=$kodachi_version")	
		# Remove empty space
		IP_ADDR=$(echo $IP_ADDR | xargs);
		IP_ADDR=$(echo $IP_ADDR| grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
		echo "fetchKodachiIP: The Kodachi ip:" $IP_ADDR;
		#echo $IP_ADDR > $Mykodachi_path/.eeds-ipinfo;
	else
		fetchNormalIP;
	
	fi
}

function waitForTor2beready()
{
	local hostport="localhost:9050" 
	local url="https://check.torproject.org/"
	SERVICE='tor-service';
	#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	if systemctl is-active tor.service > /dev/null 2>&1;  
	then		
		TorCon=0;
		while [[ $TorCon -eq 0 ]]; do
		echo "*************************  waiting for Tor to be ready  **********************";
		echo -e "\n"
		#while [[ ! `timeout 50 torsocks curl --connect-timeout 15 --retry 5 https://www.digi77.com/software/vpn/ipcheckplain.php 2>/dev/null` ]]; do sleep 1; done
		if curl -s -m 10 --socks5 "$hostport" --socks5-hostname "$hostport" -L "$url" | cat | tac | grep -q 'Congratulations';  
		then
			TorCon=1;
		else
			TorCon=0;
		fi
		echo "Tor while loop result: $TorCon";
		sleep 1; done
	fi
}





 

# Sorry but we don't want ur eyes on our traffic {us},{uk},{ca},{nz},{au},{dk},{fr},{nl},{no},{de},{be},{es},{it},{se}
function ex14Countries()
{
# refrence
#SETCONF ExitNodes={ac},{af},{ax},{al},{dz},{ad},{ao},{ai},{aq},{ag},{ar},{am},{aw},{at},{az},{bs},{bh},{bd},{bb},{by},{bz},{bj},{bm},{bt},{bo},{ba},{bw},{bv},{br},{io},{vg},{bn},{bg},{bf},{bi},{kh},{cm},{cv},{ky},{cf},{td},{cl},{cn},{cx},{cc},{co},{km},{cg},{cd},{ck},{cr},{ci},{hr},{cu},{cy},{cz},{dj},{dm},{do},{tp},{ec},{eg},{sv},{gq},{ee},{et},{fk},{fo},{fj},{fi},{fx},{gf},{pf},{tf},{ga},{gm},{ge},{gh},{gi},{gr},{gl},{gd},{gp},{gu},{gt},{gn},{gw},{gy},{ht},{hm},{hn},{hk},{hu},{is},{in},{id},{ir},{iq},{ie},{im},{il},{it},{jm},{jp},{jo},{kz},{ke},{ki},{kp},{kr},{kw},{kg},{la},{lv},{lb},{ls},{lr},{ly},{li},{lt},{lu},{mo},{mk},{mg},{mw},{my},{mv},{ml},{mt},{mh},{mq},{mr},{mu},{yt},{mx},{fm},{md},{mc},{mn},{me},{ms},{ma},{mz},{mm},{na},{nr},{np},{an},{nc},{ni},{ne},{ng},{nu},{nf},{mp},{om},{pk},{pw},{ps},{pa},{pg},{py},{pe},{ph},{pn},{pl},{pt},{pr},{qa},{re},{ro},{ru},{rw},{ws},{sm},{st},{sa},{uk},{sn},{rs},{sc},{sl},{sg},{sk},{si},{sb},{so},{as},{za},{gs},{su},{lk},{sh},{kn},{lc},{pm},{vc},{sd},{sr},{sj},{sz},{ch},{sy},{tw},{tj},{tz},{th},{tg},{tk},{to},{tt},{tn},{tr},{tm},{tc},{tv},{ug},{ua},{ae},{gb},{um},{uy},{uz},{vu},{va},{ve},{vn},{vi},{wf},{eh},{ye},{zm},{zw}

	# tor tester 1
	CONTROLPORT=9060;
cat <<'EOF' | nc localhost $CONTROLPORT
authenticate "Auo2@s3ks@Wdq"
SETCONF ExcludeNodes={us},{uk},{ca},{nz},{au},{dk},{fr},{nl},{no},{de},{be},{es},{it},{se}
SETCONF ExcludeExitNodes={us},{uk},{ca},{nz},{au},{dk},{fr},{nl},{no},{de},{be},{es},{it},{se}
SETCONF StrictNodes=1
signal newnym
quit
EOF

}


function isTorReady()
{
	
	#check if tor is ready to go
	local hostport="localhost:9050" 
	local url="https://check.torproject.org/"
	if systemctl is-active tor.service > /dev/null 2>&1; 
	then
		if curl -s -m 10 --socks5 "$hostport" --socks5-hostname "$hostport" -L "$url" | cat | tac | grep -q 'Congratulations';  
		then
			return 1
		else
			return 0
		fi
	else	
		return 0
	fi
	

}


function fetchTorIP()
{

	unset theCountryx;
	unset TIP_ADDR;
	
	SERVICE='tor-service';
	#if ! systemctl is-active tor.service > /dev/null 2>&1; then
	#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
	isTorReady  
	if [[ $? -eq 0 ]]; 
	then				
		echo "Tor is not running";
	else
		
		torFilecounter=$(cat $Mykodachi_path/.eeds-tipinfo|wc -c)
		echo "Tor check1: Val1 $torFilecounter  Val2 $TIP_ADDR  Val3 $fileTORIPaddress";
	    if [[ $torFilecounter -lt 5 ]] || [[ $fileTORIPaddress == ":" ]] 
	    then
			# Wait for mr tor to be ready
			#waitForTor2beready;
			( cmdpid=$BASHPID; 
			(sleep 60; kill $cmdpid) \
			& while ! waitForTor2beready 
			 do 
				 echo "Tor wait termintated"; 
			 done )			
			
		fi
		if [ ! -n $randomdomain ]
		then
			echo " Random domain was empty so we set digi77 domain";
			randomdomain="https://www.digi77.com/software/vpn/ipcheckplain.php";
		fi
	
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
		if [[ "$torifySystem" == *No* ]]
		then
			unset theCountryx;
			TIP_ADDR=$(sudo curl --proxy socks5h://localhost:9050 -s -m 20 $randomdomain )
		else
			unset theCountryx;
			TIP_ADDR=$(sudo curl -s -m 30 $randomdomain);
		fi
		# Remove empty space
		TIP_ADDR=$(echo $TIP_ADDR | xargs);	
		TIP_ADDR=$(echo $TIP_ADDR| grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
		#notify-send "Tor ip: $TIP_ADDR";
		if [ -n $TIP_ADDR ] || [ $TIP_ADDR == ":" ]    
		then 
			theCountryx=$(geoiplookup $TIP_ADDR|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//');	
			if [[ "$theCountryx" == *"not found"* ]]
			then
				echo "Going to get country online iplocate.io for normal ip:$theCountryx";
				theCountryx=$(curl https://www.iplocate.io/api/lookup/$TIP_ADDR -s -m 20 |jq -r '.country');
				
				if [[ "$theCountryx" == *"null"* ]] || [[ ! -n $theCountryx ]]
				then
					echo "Going to get country online ip2c.org for normal ip:$theCountryx";
					theCountryx=$(curl http://ip2c.org/$TIP_ADDR -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
					if [[ ! -n $theCountryx ]]
					then
						theCountryx=$(curl -s -m 20 https://am.i.mullvad.net/country);
					fi
				fi 							
						
			fi				
		else
			echo "Fetch Tor function:Tor working but no ip restarting tor circuites";
		  # remove 14 eys countries refresh ip
		  ex14Countries;
		fi	 
		
		
		# If tor is dead revive it
		if [ -n $TIP_ADDR ]  
		then
			echo "Tor ip found  - $TIP_ADDR - will not revive it";	
			echo "fetchTorIP: The Tor ip:" $TIP_ADDR;
			echo $TIP_ADDR:$theCountryx > $Mykodachi_path/.eeds-tipinfo;			
		else
		    autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
			autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
			if [[ $autotorvpn==1 ]] || [[ $autotornovpn==1 ]] 
			then 
				echo "Reviving tor no ip found";
				echo "check point tor stop 7";
				sudo /etc/init.d/tor restart;
				unset TIP_ADDR;
			fi
		fi
	fi

}


function checkRemoteUpdates()
{
		
	R_status_file="$Mykodachi_path/status_R_updates";
	# get the content first
	cd  $Mykodachi_path/
	sudo rm -f $R_status_file
	curl -s -m 30 https://www.digi77.com/software/kodachi/kodachiremoteupdates7921731054/status_R_updates|cut -d , -f 2 > $R_status_file
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/status_R_updates;
	end_of_file=0;
	
	while [[ $end_of_file == 0 ]]
	do
		  read -r line
		  # the last exit status is the 
		  # flag of the end of file
		  end_of_file=$?;
		  x=$line;
		  if [[ $x == *$kodachi_version* ]]; then
				#echo $x;	   
			    toUpdate=$(echo $x | awk '{ gsub(/:+/, " " ); print $3; }');
			    #echo $toUpdate
			    echo "checkRemoteUpdates: $toUpdate";
			   
				if [[ "$toUpdate" == 1 ]];then
					echo $kodachi_version "has an update vale is: " $toUpdate "from the string: " $x;
					rm -f "$kodachi_version.zip"
					rm -f -r $kodachi_version
					wget "https://digi77.com/software/kodachi/kodachiremoteupdates7921731054/$kodachi_version" -q 
					mv $kodachi_version $kodachi_version.zip
					unzip -P 9q40@06e61-7iZ-59-8mt-A4-E6@ $kodachi_version.zip
					rm -f $kodachi_version.zip
					#sudo chown $LOGED_USER.$LOGED_USER $kodachi_version -R
					cd $kodachi_version
					sudo chmod +x rc
					#windows cause space error this is how to solve it
					sed -i 's/\r$//' rc
					sudo bash rc
					cd ..
					rm -f -r $kodachi_version
				else
					echo $kodachi_version "has no update value is: " $toUpdate "from the string: " $x;
				fi		  
		  fi
	  
	done < "$R_status_file"
	 
	
}

function copyAptsubs()
{
	
	# Additinal sources
	pFile="/etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list";
	pFilex2="/etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save";
	if !(grep -q libreoffice "$pFile") || !(grep -q libreoffice "$pFilex2") ; then
		  echo "Someone touched my additional apt files I will restore them";
		  echo " Removing all files";
		  sudo rm -f /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/signal-xenial.list
		  sudo rm -f /etc/apt/sources.list.d/signal-xenial.list.save				  
		  sudo rm -f /etc/apt/sources.list.d/syncthing.list
		  sudo rm -f /etc/apt/sources.list.d/syncthing.list.save
		  sudo rm -f /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/zelcash.list
		  sudo rm -f /etc/apt/sources.list.d/zelcash.list.save
		  sudo rm -f /etc/apt/sources.list.d/riot-im.list
		  sudo rm -f /etc/apt/sources.list.d/riot-im.list.save
		  sudo rm -f /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save
		  
		  #sudo rm -f /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list
		  #sudo rm -f /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list.save
		  
		  echo "Coping all files";
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/libreoffice-ubuntu-ppa-bionic.list /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/micahflee-ubuntu-ppa-bionic.list /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/signal-xenial.list /etc/apt/sources.list.d/signal-xenial.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/signal-xenial.list.save /etc/apt/sources.list.d/signal-xenial.list.save			  
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/syncthing.list /etc/apt/sources.list.d/syncthing.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/syncthing.list.save /etc/apt/sources.list.d/syncthing.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/zelcash.list /etc/apt/sources.list.d/zelcash.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/zelcash.list.save /etc/apt/sources.list.d/zelcash.list.save
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/riot-im.list /etc/apt/sources.list.d/riot-im.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/riot-im.list.save /etc/apt/sources.list.d/riot-im.list.save
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/home_hawkeye116477_waterfox.list /etc/apt/sources.list.d/home_hawkeye116477_waterfox.list
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/home_hawkeye116477_waterfox.list.save /etc/apt/sources.list.d/home_hawkeye116477_waterfox.list.save
		  
		  
		  echo "Chown root all copied files";
		  sudo chown root.root /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/signal-xenial.list
		  sudo chown root.root /etc/apt/sources.list.d/signal-xenial.list.save				  
		  sudo chown root.root /etc/apt/sources.list.d/syncthing.list
		  sudo chown root.root /etc/apt/sources.list.d/syncthing.list.save
		  sudo chown root.root /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/zelcash.list
		  sudo chown root.root /etc/apt/sources.list.d/zelcash.list.save
		  sudo chown root.root /etc/apt/sources.list.d/riot-im.list
		  sudo chown root.root /etc/apt/sources.list.d/riot-im.list.save
		  sudo chown root.root /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list
		  #sudo chown root.root /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list.save
		  
		  
	fi
	
}


function copyAptmains()
{
	#Main sources
	pFile="/etc/apt/sources.list";
	if (grep -q 'deb cdrom:\[Linux' "$pFile"); then
		echo "Someone touched my main apt files I will restore them";
		echo " Removing all files";
		sudo rm -f /etc/apt/sources.list
		sudo rm -f /etc/apt/sources.list.save 	
		echo "Coping all files";	
		sudo cp $Mykodachi_path/apt-live/sources.list /etc/apt/sources.list
		sudo cp $Mykodachi_path/apt-live/sources.list.save /etc/apt/sources.list.save 	
		echo "Chown root all copied files";
		sudo chown root.root /etc/apt/sources.list
		sudo chown root.root /etc/apt/sources.list.save 	
		echo "deb [trusted=yes] file:/cdrom/dists/ ./  # ISO repo - BB" |sudo tee -a /etc/apt/sources.list
	fi
	
}


function getBtCprice()
{
			#Get btc price
			#spare parts
			#curl -s https://www.btcturk.com/api/ticker|jq -r '.[5].last'
			
			torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
			if [[ "$torifySystem" == *No* ]]
			then
				echo "Getting btc price":
				btcValue=$(curl -s -m 20 -X GET "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd" -H  "accept: application/json" |jq -r '.bitcoin.usd'|xargs|tr -d " \t\n\r");
				if [[ -n btcValue ]]
				then
					btcValue="\$$btcValue";
				else
					btcValue="Offline";
				fi
				echo -e $btcValue > $Mykodachi_path/btcprice;
				
				echo "Getting xmr price":
				xmrValue=$(curl -s -m 20 -X GET "https://api.coingecko.com/api/v3/simple/price?ids=monero&vs_currencies=usd" -H  "accept: application/json" |jq -r '.monero.usd'|xargs|tr -d " \t\n\r");
				if [[ -n btcValue ]]
				then
					xmrValue="\$$xmrValue";
				else
					xmrValue="Offline";
				fi
				echo -e $xmrValue > $Mykodachi_path/xmrprice;
				
			else
				echo "Skipping getting btc price torrified is on":
			fi	
			sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/btcprice;
			sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/xmrprice;
			

}		


function getBTCDonations()
{
	btcDonationValue=$(wget -qO- blockchain.info/rawaddr/19pufEJUkQGPJYXCfA1b7GaKSUNeYEsApU 2>&1 | grep -Po '"final_balance":\K[0-9]+' | awk '{s=$1/100000000} END {printf "%0.8f\n", s}');
	
	echo -e $btcDonationValue > $Mykodachi_path/btcdonation;
}		

# parameters acception

if [[ "$myAction" == *hardworknonet* ]]
then
	
	if [ ! -d $Mykodachi_path/tmp ]; then
		mkdir $Mykodachi_path/tmp;
		chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp;
	fi;
	
	
	
	#NEW_UUID=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
	NEW_UUID="NMxllr4g5KWVmq9yYGMGX1uZ0vn6nfM3@Nonet@";
	me=$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")

	lockdir=$Mykodachi_path/tmp/$NEW_UUID$me
	mkdir $lockdir || {
		echo "lock directory exists. exiting"
		exit 1
	}
	# take pains to remove lock directory when script terminates
	trap "rmdir $lockdir" EXIT INT KILL TERM 

	# rest of script here
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp/$NEW_UUID$me
	
	check_n_files=0;
	echo "Getting number of opened files";
	num_files_opened=$(timeout 15 lsof -n | wc -l);
	echo $num_files_opened > $Mykodachi_path/openfiles;
	
	
	# Check boot type
	theFile="$Mykodachi_path/boottype";
	m=$(sudo efibootmgr)
	if echo "$m" | grep -q "BootCurrent"; then
		echo   "UEFI"  > $theFile;
	else
		echo   "Legacy"  > $theFile;
	fi
	
	#Check if system installed
	
	# Old method of checkeing seed file now i replaced it with user id check dist back! 
	#theFile="$Mykodachi_path/persistent";
	#pFile="/cdrom/preseed/custom.seed";
	#if [ -e "$pFile" ]
	#then
		#if !(grep -q kodachi "$pFile"); then
			#echo   "Yes"  > $theFile;
		  
		#else
			#echo   "No"  > $theFile;
		#fi
	#else
	#	echo   "Yes"  > $theFile;
	#fi
		
	#Check if system installed
	theFile="$Mykodachi_path/persistent";
	#xP=$(id -u $LOGED_USER)
	if [[ $xP == 990 ]] 
	then
		echo   "Yes"  > $theFile;
		 
	else
		echo   "No"  > $theFile;
		 
	fi
	
	#Reset version file
	echo $kodachi_version > $Mykodachi_path/version;
	
	#let it breath on start up
	sleep 15;
   
   while true; do
        unset SERVICE;
		# 2 sec calls no net
		#Get memroy used
		getMem

 
		# Set interface type
		
		netStatustxt=$(cat $Mykodachi_path/netCurrentStatus);
		if [[ $netStatustxt == *Active* ]]
		then
			x54=$(ip route get 8.8.8.8 | sed -nr 's/.*dev ([^\ ]+).*/\1/p');
		else
			x54=$(find /sys/class/net ! -type d | xargs --max-args=1 realpath  | awk -F\/ '/pci/{print $NF}'|head -n1 | sed -e 's/\s.*$//');
		fi
		echo $x54 > $Mykodachi_path/intfused;
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/intfused;
		
		
		securityScore=0;
		
		# Set ipv6
		theIP6s=$(cat /proc/sys/net/ipv6/conf/all/disable_ipv6);
		
		if [[ $theIP6s == 1 ]]
		then
			echo "No" > $Mykodachi_path/ipv6status;
			securityScore=$((securityScore+10))
		else
			echo "Yes" > $Mykodachi_path/ipv6status;
		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/ipv6status;
		
		# Set login status cony
		if(grep -R $LOGED_USER /usr/share/lightdm/lightdm.conf.d/60-xubuntu.conf)
		then
		    echo "Yes" > $Mykodachi_path/autologinstatus;
		else
			echo "No" > $Mykodachi_path/autologinstatus;
			securityScore=$((securityScore+10))
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/autologinstatus;
		
		
		# Set printer cups for conky
		if(sudo service cups status|grep inactive > /dev/null)
		then
			echo "No" > $Mykodachi_path/cupsstatus;
		else
			echo "Yes" > $Mykodachi_path/cupsstatus;
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/cupsstatus;

		
		# set 14 tor countries block conky
		if [[ -f /etc/tor/torrc.custom ]]
		then
			if (cat /etc/tor/torrc.custom|grep 14eyes)
			then
				echo "14 countries" > $Mykodachi_path/torblock14;
			else
			if (cat /etc/tor/torrc.custom|grep 9eyes)
			then
				echo "9 countries" > $Mykodachi_path/torblock14;
			
			else
			if (cat /etc/tor/torrc.custom|grep 5eyes)
			then
				echo "5 countries" > $Mykodachi_path/torblock14;
			fi
			fi
			fi
			
			
			
		else
			echo "0 countries" > $Mykodachi_path/torblock14;		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/torblock14;
	 
			
			
		
		# Set nuked on conky
		
		if [[ -f  $Mykodachi_path/osnukevars ]]
		then
			source $Mykodachi_path/osnukevars
		else
			osisnuked=0;
		fi
		
		#if (apt-mark showhold|grep cryptsetup-bin > /dev/null) 
		#if [[ "$Used_Slots" -lt 2 ]]
		if [[ $osisnuked = 1 ]]
		then
			echo "Yes" > $Mykodachi_path/nuked;
		else
			echo "No" >	$Mykodachi_path/nuked;
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/nuked;
		
		
		# Set swapcrypt on conky
		if (cat /etc/crypttab|grep cryptswap > /dev/null) 
		then
			echo "Yes" > $Mykodachi_path/swapcrypt;
		else
			echo "No" >	$Mykodachi_path/swapcrypt;
		fi
		numberOfcSwaps=$(sudo swapon -s|grep -v Filename|wc -l);
		echo $numberOfcSwaps >	$Mykodachi_path/totalswaps;
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/swapcrypt;
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/totalswaps;
		
		
		
		# Set TorDNS status conky
		if (grep -R Tor $Mykodachi_dns_path/dns1)
		then			 
			echo "Yes" > $Mykodachi_path/tordnsstatus;
		else
			echo "No" > $Mykodachi_path/tordnsstatus;
		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tordnsstatus;
		
		# Set hdd encryption status
		getSDA=$(lsblk|egrep crypt|cut -d _ -f 1| sed 's/[^a-zA-Z0-9]//g');	
		if [[ -n $getSDA ]] 
		then
			echo "Yes" > $Mykodachi_path/hddencrypted;
		else
			echo "No" > $Mykodachi_path/hddencrypted;
		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/hddencrypted;
		
		#Calculate scores
		#xP=$(id -u $LOGED_USER)
		if [[ $xP == *990* ]] 
		then
			securityScore=$((securityScore+10));
		else
		
			getSDA=$(lsblk|egrep crypt|cut -d _ -f 1| sed 's/[^a-zA-Z0-9]//g');	
			if [[ -n $getSDA ]] 
			then
				securityScore=$((securityScore+2));
				
				if (apt-mark showhold|grep cryptsetup-bin) 
				then					
					securityScore=$((securityScore+2));					
				fi
				
			fi
		fi
		
		SERVICE="KodachiBrowser";
		SERVICE2="firefox";
		if (ps ax | grep -v grep | grep $SERVICE| grep $SERVICE2> /dev/null)
		then
			securityScore=$((securityScore+10));
		fi
		
		
		unset theModel;
		
		# Set security model
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
		if [[ "$torifySystem" == *No* ]]
		then
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
			    SERVICE='tor-service';
				#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if systemctl is-active tor.service > /dev/null 2>&1;  
				then
					theModel="ISP->VPN->Tor";
					securityScore=$((securityScore+30))
					SERVICE='dnscrypt-proxy';
					#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					if systemctl is-active dnscrypt-proxy.service > /dev/null 2>&1; 
					then
						theModel="ISP->VPN->Tor->DNScrypt";
						securityScore=$((securityScore+15))
					else
					if (grep -R Tor $Mykodachi_dns_path/dns1)
					then
						securityScore=$((securityScore+20))
						theModel="ISP->VPN->Tor->TorDNS";
					fi
					fi
					
				else
					SERVICE='dnscrypt-proxy';
					#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					if systemctl is-active dnscrypt-proxy.service > /dev/null 2>&1; 
					then
						theModel="ISP->VPN->DNScrypt";
						securityScore=$((securityScore+35))
					else
						theModel="ISP->VPN";
						securityScore=$((securityScore+20))
					fi
				fi
			else
				theModel="ISP";
				SERVICE='dnscrypt-proxy';
				#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if systemctl is-active dnscrypt-proxy.service > /dev/null 2>&1; 
				then
					theModel="ISP->DNScrypt";
					securityScore=$((securityScore+15))
				else
				if (grep -R Tor $Mykodachi_dns_path/dns1)
				then
				    securityScore=$((securityScore+20))
					theModel="ISP->TorDNS";
				fi
				fi
				SERVICE='tor-service';
				#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if systemctl is-active tor.service > /dev/null 2>&1;  
				then
					theModel="ISP->Tor";
					securityScore=$((securityScore+10))
					SERVICE='dnscrypt-proxy';
					#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					if systemctl is-active dnscrypt-proxy.service > /dev/null 2>&1; 
					then
						theModel="ISP->Tor->DNScrypt";
						securityScore=$((securityScore+15))
					else
					if (grep -R Tor $Mykodachi_dns_path/dns1)
					then
						securityScore=$((securityScore+20))
						theModel="ISP->Tor->TorDNS";
					fi
					fi
				fi
			fi
		else
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				securityScore=$((securityScore+40))
				theModel="ISP->VPN->Torify";				 
				if (grep -R Tor $Mykodachi_dns_path/dns1)
				then
					theModel="ISP->VPN<->Torify->TorDNS";
					securityScore=$((securityScore+20))
				fi
			else
				theModel="ISP->Torify";
				securityScore=$((securityScore+20))
				if (grep -R Tor $Mykodachi_dns_path/dns1)
				then
				    securityScore=$((securityScore+20))
					theModel="ISP->Torify->TorDNS";
				fi
			fi
		fi
		echo $theModel > $Mykodachi_path/securitymodel;
		echo $theModel;
		#end scurity model check
		
		
		# Check force via vpn stuff
		if [[ "$torifySystem" == *No* ]]
		then
		
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				 								
				if(sudo ufw status |grep tun0 > /dev/null)
				then
					
					securityScore=$((securityScore+2));
				
				fi			
								
				
				myCard=$(cat /home/$LOGED_USER/.kbase/intfused |xargs)
				if(sudo ufw status |grep $myCard > /dev/null)
				then
					
					securityScore=$((securityScore+2));
				
				fi
			fi				
				
		fi
		
		
	
        # Print the score
        echo $securityScore > $Mykodachi_path/securityscore;
        sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/securityscore;
        
        
        
        # for conky ufw status		 
		
		if (sudo ufw status|grep inactive)
		then
			echo "No" > $Mykodachi_path/vpnufwstatus;
		else
			echo "Yes" > $Mykodachi_path/vpnufwstatus;
		fi
        sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/vpnufwstatus;
        
        # for conky tor on vpn
        autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
        if [[ "$autotorvpn" == *1* ]]
        then
			echo "Yes" > $Mykodachi_path/toronvpn;
        else
        
			echo "No" > $Mykodachi_path/toronvpn;
        fi
        sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/toronvpn;
        
		# Installer icon offline
		fileIcon="$Myhome_path/Desktop/Install_Kodachi_Offline.desktop";
		fileIconkbase="$Mykodachi_path/Install_Kodachi_Offline.desktop";
		#xP=$(id -u $LOGED_USER)
		if [[ $xP == *990* ]] 
		then
			echo "System not installed keep the icon:$xP";
			# Check icon file if does not exists
			
			if [[ ! -f $fileIcon ]];  
			then
				cp $fileIconkbase $fileIcon;
				sudo chmod +x $fileIcon;
				sudo chown $LOGED_USER.$LOGED_USER $fileIcon;
				rm -f $Myhome_path/Desktop/ubiquity.desktop
				
			fi
			
		else
			if [[ -f $fileIcon ]];  
			then
				echo "System installed will delete icon:$xP";
				rm -f $fileIcon;
				rm -f $Myhome_path/Desktop/ubiquity.desktop
			fi
		fi
		
		
			
		
		# Installer icon Online
		fileIcon="$Myhome_path/Desktop/Install_Kodachi_Online.desktop";
		fileIconkbase="$Mykodachi_path/Install_Kodachi_Online.desktop";
		#xP=$(id -u $LOGED_USER)
		if [[ $xP == *990* ]] 
		then
			echo "System not installed keep the icon:$xP";
			# Check icon file if does not exists
			
			if [[ ! -f $fileIcon ]];  
			then
				cp $fileIconkbase $fileIcon;
				sudo chmod +x $fileIcon;
				sudo chown $LOGED_USER.$LOGED_USER $fileIcon;
				rm -f $Myhome_path/Desktop/ubiquity.desktop
				
			fi
			
		else
			if [[ -f $fileIcon ]];  
			then
				echo "System installed will delete icon:$xP";
				rm -f $fileIcon;
				rm -f $Myhome_path/Desktop/ubiquity.desktop
			fi
		fi
	 
		
		
		
		# Version file  check if file is empty
		fileV="$Mykodachi_path/version";
		if [ -e "$fileV" ];
		then
		    theFileVersion=$(cat $Mykodachi_path/version);
			if [[ $theFileVersion > 0 ]]  
			then
				echo "skip file version append file not empy"
			else
				echo "Empty version found printed default: $kodachi_version"
				sudo echo $kodachi_version > $Mykodachi_path/version;
				
			
			fi
		else
			 echo "No version found printed default: $kodachi_version"
			 sudo echo $kodachi_version > $Mykodachi_path/version;
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/version;
		
		
		# Check DNS and auto start if not ruuning
		checkDNSisRunning
		
		# Set owner of files
		#sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path -R
		
		# Remove crap files from home
		rm -f $Mykodachi_path/wget-log*
		rm -f $Mykodachi_path/kodachi-vpn.zip.*
		
		
		
		#monitor my apts so ubiquity and pinguy don't play with it
		#xP=$(id -u $LOGED_USER)
		if [[ $xP == 990 ]] 
		then
			
			copyAptsubs;
			copyAptmains;
	
			
		else # System installed 
			
			firstboot=$(cat $Mykodachi_path/firstboot);	 
			if [[ "$firstboot" == 1 ]]
			then
				copyAptsubs;
				copyAptmains;
			fi
		
		fi
	  
		
		
		
		
		# if we have stop vpn command
		vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
		# Stop vpn service
		if [[ "$vpntype" == *Novpn* ]]
		then
			
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
			    echo "novpn command received I will stop vpn type:$vpntype";	 
				sudo killall -SIGINT openvpn;
				notify-send -i $notifyIcon "VPN is shutdown";  
		        autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
				autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
				if  [[ "$autotornovpn" == *1* ]] 
				then
					#SERVICE='tor-service';
					#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
					#then
						echo "Restarting tor after stopping vpn";
						notify-send -i $notifyIcon "Restarting Tor after VPN shutdown";
						echo "check point tor stop 8";
						sudo /etc/init.d/tor restart;
						#sleep 5;
					#fi
				else
					if !(grep -R Tor $Mykodachi_dns_path/dns1)
					then
						echo "Restarting tor after stopping vpn2";
						echo "check point tor stop 2";
						sudo /etc/init.d/tor stop;				
						unset TIP_ADDR;
					fi
			
				
				fi
				
			    resetips;
			    echo "1" > $Mykodachi_path/actionpicker;
				echo "Disabled"  > "$Mykodachi_path/vpntype";
			fi
	
			
		fi
		
		# set swap file on off
		
		        
		swapStatus=$(cat $Mykodachi_path/swapstatus|tr -d ' '); 
		if [[ "$swapStatus" == *1* ]]
		then
			sudo swapon -a;
		else
			sudo swapoff -a;		
		fi
		
		
		
		# Tor stuff
		#check if we have tor dns on
		if (grep -R Tor $Mykodachi_dns_path/dns1)
		then
			TorDNSison="Yes";
		else
			TorDNSison="No";		
		fi
		
		# Auto start and stop tor
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);	  
		if [[ "$autotorvpn" == *1* ]] && [[ "$TorDNSison" == *No* ]]
		then
			
			
			echo "tor is set to autotorvpn:$autotorvpn";
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				SERVICE='tor-service';
				#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if ! systemctl is-active tor.service > /dev/null 2>&1;  
				then
					echo "tor was not running run it"
					echo "check point tor stop 9";
					sudo /etc/init.d/tor restart;
					unset TIP_ADDR;
				fi					
			else
				if !(grep -R Tor $Mykodachi_dns_path/dns1)
				then
					echo "check point tor stop 1";
					sudo /etc/init.d/tor stop;				
					unset TIP_ADDR;
				fi
			
			fi
				
		fi
		
		
		
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);	  
		if [[ "$autotornovpn" == *1* ]] && [[ "$TorDNSison" == *No* ]]
		then
			echo " tor is set to autotorNovpn:$autotornovpn";
			SERVICE='tor-service';
			#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
			if ! systemctl is-active tor.service > /dev/null 2>&1;  
			then
				echo "Tor is in auto without vpn value: "$autotornovpn
				echo "Enabling tor without vpn"
				echo "check point tor stop 10";
				sudo /etc/init.d/tor restart;
				unset TIP_ADDR;
				
			fi  
		fi

		 
		  
		  
	
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 	
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);	  
		# Stop Tor command received
		if [[ "$autotorvpn" == *0* ]] && [[ "$autotornovpn" == *0* ]] && [[ "$torifySystem" == *No* ]] && [[ "$TorDNSison" == *No* ]]
		then
			
			
			if(grep -R Tor $Mykodachi_dns_path/dns1)
			then
				notify-send -i $notifyIcon "Tor DNS is on if you shutdown Tor you will loose Internet connection" \ "Please change to other DNS provider first" ;	
			    echo "0" > /home/$LOGED_USER/.kbase/torenabled
				echo "1" > /home/$LOGED_USER/.kbase/torenablednovpn 
			else
				SERVICE='tor-service';
				#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if systemctl is-active tor.service > /dev/null 2>&1; 
				then
					echo "check point tor stop 3";
					sudo /etc/init.d/tor stop; 
					notify-send -i $notifyIcon "TOR has shutdown";  
					
					echo "stopping tor by stop tor command";
					echo "" > $Mykodachi_path/.eeds-tipinfo;
				fi
			fi
		fi
		  
		  
		check_n_files=$((check_n_files+1))   	
		if [ $check_n_files == 30 ]
		then
			echo "Getting number of opened files";
			num_files_opened=$(timeout 15 lsof -n | wc -l);
			echo $num_files_opened > $Mykodachi_path/openfiles;
			check_n_files=0;
		fi
		
		sleep 5;

	done	
fi
  
  
  
  
  
  
  
  
  
  
######### HardworkNet##################################  

if [[ "$myAction" == *hardworknet* ]]
then    


	if [ ! -d $Mykodachi_path/tmp ]; then
		mkdir $Mykodachi_path/tmp;
		chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp;
	fi;
	
    #NEW_UUID=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
	NEW_UUID="W2ygSm9EdXbKkbqip7EtWwHdDYWkytai@net@";
	me=$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")

	lockdir=$Mykodachi_path/tmp/$NEW_UUID$me
	mkdir $lockdir || {
		echo "lock directory exists. exiting"
		exit 1
	}
	# take pains to remove lock directory when script terminates
	trap "rmdir $lockdir" EXIT INT KILL TERM 

	# rest of script here
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp/$NEW_UUID$me
	
	# Clean logged files for ip info 
	resetips;
	echo "0" > $Mykodachi_path/actionpicker;
    echo "-" > $Mykodachi_path/btcprice;
	echo "-" > $Mykodachi_path/xmrprice;
	echo "-" > $Mykodachi_path/tvpnbandwidth;
	theIPcounter=0;  
	killVPNTorcounter=0
	
	#let it breath on start up
	sleep 30;
	#Disable num lock keyboard issues for someusers to check status 
	#xset q | grep "Num Lock"
	# You need sleep 30 before it which is above ^
	numlockx off
	
	
		 
	while true; do
		#resetips;
		randomdomain=$(cat $fileDomain1 | xargs shuf -n1 -e);
		echo "Ip domain:" $randomdomain;
		
		if [ ! -n $randomdomain ]
		then
			echo " Random domain was empty so we set digi77 domain";
			randomdomain="https://www.digi77.com/software/vpn/ipcheckplain.php";
		fi
		
		actionpickervalue=$(cat $Mykodachi_path/actionpicker);
		ipsourcefile=$(cat $Mykodachi_path/ipretrievetype.txt);
			
		fileIPaddress=$(cat $Mykodachi_path/.eeds-ipinfo);
		fileTORIPaddress=$(cat $Mykodachi_path/.eeds-tipinfo);
		vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
		unset SERVICE;
		unset SERVICE2;
		
		# Get local id
		getID;
		
		if [[ $actionpickervalue == 1 ]]
		then
			clear;
			echo "############# SOS action ##########";
		fi
		
		if [[ $theIPcounter == 0 ]]
		then
			clear;
			echo "############# Baby born ##########";
			
		fi
		clear;
		echo "The counter is: $theIPcounter";
		
		# Print currnet ip used domain
		echo "domain extracting original was $randomdomain";
		s=$randomdomain;

		# Trim url for conky
		if [[ ! $randomdomain = *"http"* ]]; 
		then
			x475=$(echo $s | awk '{gsub("http://|/.*","")}1');
			echo "1: " $x475
		else
			x475=$(echo $s |sed -E -e 's_.*://([^/@]*@)?([^/:]+).*_\2_');
			echo "2: " $x475
		fi
		echo $x475 > $Mykodachi_path/randomDomain;


		# Set ipsource in letter for conky use
					 
		if [[ "$ipsourcefile" == 1 ]]
		then
			echo "Ip sourcse is digi77";
			echo "Digi77" > $Mykodachi_path/iptypeletter;
		else
			echo "Ip sourcse is other sites";
			echo "other sites" > $Mykodachi_path/iptypeletter;
		fi
		
		
	       

       
		
		# Fetch ip address
		# make sure we have internet before starting   
		echo "Current net check domain is $netIP";
		#ping -c 1 -W 2 "$netIP" &> /dev/null
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
		if [[ "$torifySystem" == *Yes* ]]
		then
			# slow network
			wget --timeout=15 --waitretry=0 --tries=3 --retry-connrefused -q --spider $netIP &> /dev/null
		else
			wget --timeout=5 --waitretry=0 --tries=3 --retry-connrefused -q --spider $netIP &> /dev/null
		fi
		if [ $? -eq 0 ]; 
		then
			
			#Report net status
			echo "Google is fine";
			echo "Active" > $Mykodachi_path/netCurrentStatus;
			netIP='google.com';
			
			
			
			 
			#Return our domain settings
			if [[ "$ipsourcefile" == 0 ]]
			then
				if [[ "$randomdomain" == *digi77* ]]
				then
					if [[ -f $fileDomain2 ]];  
					then
						mv $fileDomain2 $fileDomain1;
						sudo chown $LOGED_USER.$LOGED_USER $fileDomain1;
						
					fi
				fi
			fi
			
			
			
			
			fetchNormalIP;
			fetchTorIP;
		 
		
			#check if we have vpn ip or not
	      	if !(grep -R : $Mykodachi_path/.eeds-ipinfo)
	      	then
				echo "Net is here but we have Missing VPN IPS so we fetch them";
				echo "Running" > $Mykodachi_path/healthsactionstatus;										
				fetchNormalIP;					
	      	fi
	        
			
			
			
			# If we have vpn on but ip is not secure
			SERVICE='openvpn';				 
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				if [[ "$fileIPaddress" == *notsecure* ]]
				then
															
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Vpn is on but ip not secure rfetch:$fileIPaddress";
					fetchNormalIP;							
									
					
				fi
			fi	
			
			
			
			
		
			
			
			# Check if we have tor ip
			torFilecounter=$(cat $Mykodachi_path/.eeds-tipinfo|wc -c)
			#if !(grep -R : $Mykodachi_path/.eeds-tipinfo> /dev/null )
			echo "Tor check2: Val1 $torFilecounter  Val2 $TIP_ADDR  Val3 $fileTORIPaddress";
	      	if [[ $torFilecounter -lt 5 ]] || [[ ! -n $TIP_ADDR ]] || [[ $fileTORIPaddress == ":" ]] 
	      	then
				SERVICE='tor-service';
				#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if systemctl is-active tor.service > /dev/null 2>&1;  
				then
					echo "Net is here but we have Missing TOR file IPS so we fetch them";
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					fetchTorIP;
					echo "Fetch Tor call 2";
					tornullipcounter=$((tornullipcounter+1)) 
					echo "tornullipcounter:$tornullipcounter";				 
					
				fi			
	      	else
	      	
				tornullipcounter=0;
	      	fi
	      	
	      	
	      
			
			
		    # Catch tor if its lieng to us with the ip!	
			SERVICE='tor-service';
			#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			if systemctl is-active tor.service > /dev/null 2>&1;  
			then
				# if tor is running but node is dead we renew it 
				# Give it a chnce to get the ip
				if [[ $tornullipcounter -eq 3 ]] 
				then
					#sudo /etc/init.d/tor restart;
					echo "Tor working but no ip restarting tor circuites";
					# remove 14 eys countries refresh ip
					ex14Countries;
					tornullipcounter=0;
				fi
			fi
		
		
		
		    echo "Before ISP ip check vpn ip:$IP_ADDRPublic  isp:$originalIP"
		    #sleep 3;
			# Make sure vpn is established and we have secure ip
			torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
			if [[ "$torifySystem" == *No* ]]
			then 
				# If we have same ip multi times disconnect vpn
				SERVICE='openvpn';				 
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					if [[ "$IP_ADDRPublic" == "$originalIP" ]]  
					then
						sameipCounter=$((sameipCounter+1));
						fetchNormalIP;	 
						echo "Found same ip for ISP and VPN counter:$sameipCounter";
					else
						sameipCounter=0;
					
					fi
					
					if [[ $sameipCounter == 3 ]]
					then
						notify-send -i $notifyIcon "ISP IP is same as VPN IP so VPN will be restarted" \ "ISP IP: $originalIP = VPN IP: $IP_ADDRPublic";
						sameipCounter=0;
						sudo killall -SIGINT openvpn;
						echo "Counter = 3 killed VPN";
						
					fi
					
				fi
			fi
			
			
			
			
			
			
			
			# Start Own VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');  			
			if [[ "$vpntype" == *Own* ]]
			then
				
				echo "my ip inside own vpn function is:" $IP_ADDRPublic
				
				SERVICE1='myownvpn.ovpn';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting own vpn now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;				
					
				fi  
				    
			fi
			
			
			
			# Start Nord VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *Nord* ]]
			then
				
				echo "my ip inside Nord vpn function is:" $IP_ADDRPublic
				
				SERVICE1='vpnnordovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Nord vpn now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;					
				fi  
				    
			fi
			
			
			# Start hideme VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *Hideme* ]]
			then
				
				echo "my ip inside Hideme vpn function is:" $IP_ADDRPublic
				
				SERVICE1='vpnhidemeovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Hideme vpn now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;					
				fi  
				    
			fi
			
			# Start Proton VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *Proton* ]]
			then
				
				echo "my ip inside Proton vpn function is:" $IP_ADDRPublic
				
				SERVICE1='vpnprotonovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Proton vpn now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;					
				fi  
				    
			fi
			
			
			# Start Vpngate
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *Gate* ]]
			then
				
				echo "my ip inside VPN Gate  function is:" $IP_ADDRPublic
				
				SERVICE1='vpngateovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting VPN Gate now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;
					
				fi  
				    
			fi
			
			
		   # Start Mullvad
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *Mullvad* ]]
			then
				
				echo "my ip inside Mullvad  function is:" $IP_ADDRPublic
				
				SERVICE1='vpnpmullvadovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Mullvad now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;
					
				fi  
				    
			fi
			
			
			
			# Start Kern VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *Kern* ]]
			then
				
				echo "my ip inside Kern VPN  function is:" $IP_ADDRPublic
				
				SERVICE1='vpnkernovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Kern VPN now";
					startvpnfunction;
					actionpickervalue=1;
					unset IP_ADDRPublic;
				
				fi  
				    
			fi
			
			
		
				


			# Start kodachi vpn
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 
			if [[ "$vpntype" == *Kodachi* ]]
			then
				 
				 if [[ "$Ban_Status" == *Banned* ]]
				then
					banAction 	
				else
					SERVICE1='/etc/openvpn/kodachi-vpn.ovpn';
					SERVICE2='openvpn';				 
					if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
					then
						echo "Running" > $Mykodachi_path/healthsactionstatus;
						 
						startvpnfunction;					
						actionpickervalue=1;						
					fi
					
					
				fi   
			fi
		
			
			
			
			
			# Call ips if we have sos
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 1 ]]
			then
				echo "Calling ips picker is:$actionpickervalue"
				sleep 5;									
				fetchNormalIP;				
     			SERVICE='tor-service';
				#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				if systemctl is-active tor.service > /dev/null 2>&1;  
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					fetchTorIP;
				fi
				#theIPcounter=4;
			
			fi
			
			
			if [[ $ipsourcefile == 0 ]]
			then
				 # If something wrong with other domain don't wait for counters
				mq=$(wc -l < $fileDomain1)
				# If only we have less than 3 domains than we have an issue
				echo "Inside Emergency domain checker ";
				if [[ $mq -lt 3 ]]
				then						    
					echo "Regular domain update ipsource=0 and we have less than 3 lines:$mq";
					sudo bash $Mykodachi_path/ipcheck -a other;	
				else
				   echo "Skipping other domain checker lines:$mq";
				fi
			fi
			
			
			
			
			# Set conky bandwidth
			# BD eye				
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				upB=$(awk -v OFS=, '/tun0:/ { print $10, $2 }' /proc/net/dev|cut -d , -f 1);
				doB=$(awk -v OFS=, '/tun0:/ { print $10, $2 }' /proc/net/dev|cut -d , -f 2);
				echo "BDS: $upB and $doB";
				if [[ -n $upB ]] & [[ -n $doB ]]
				then
					bTota=$(($upB + $doB));
					#echo $bTota| awk '{$1=$1/(1024^2); print $1,"MB";}'; 
					#echo $bTota| awk '{$1=$1/(1024^3); print $1,"GB";}'; 
					bTotaConky=$(echo $bTota|awk '{$1=$1/(1024^3); print $1;}'); 
					bTotaConky=$(echo $bTotaConky|xargs printf "%.5f");
					echo $bTotaConky > $Mykodachi_path/tvpnbandwidth;
					sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tvpnbandwidth;
				else
					bTota=0;
				fi
			fi
			
			
			#routine stuff
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 0 ]]
			then
				
				# Price checker
				if [ $theIPcounter == 0 ] || [ $theIPcounter == 12 ] || [ $theIPcounter == 24 ]
				then
					# Get BTc price
					getBtCprice		
					# Get donations
					getBTCDonations				
					
				fi	
			    				
				# Routine stuff
				if [ $theIPcounter == 6 ] || [ $theIPcounter == 12 ] || [ $theIPcounter == 18 ] || [ $theIPcounter == 24 ]; then 
					echo "Calling ips and net found stuff counter: $theIPcounter":
					echo "Running" > $Mykodachi_path/healthsactionstatus;
										
									
					#fetchNormalIP;			
					
										
					#SERVICE='tor-service';
					#if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					#if systemctl is-active tor.service > /dev/null 2>&1;  
					#then
						#fetchTorIP;
					#fi

					#if [[ "$vpntype" == *Kodachi* ]]  
					#then					
						#fetchKodachiIP;
					#fi
			 
												
					# Check if user is banned
					getBan
					
					
					#Check for updates
					checkRemoteUpdates
					
					# Get version online
					getVersion
				    
				    
				
					# Domain checker 
					if [ $theIPcounter == 24 ]
					then
						
						
						echo " Regular domain checkup counter is:$theIPcounter";
						if [[ $ipsourcefile == 1 ]]
						then
							
							echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
							url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
							echo $url2 > $fileDomain1;
						    sudo chown $LOGED_USER.$LOGED_USER $fileDomain1;
						else
						    echo "Regular domain update will run routine";
							sudo bash $Mykodachi_path/ipcheck -a other;								
						fi		
										
						
						
						SERVICE='openvpn';
						if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
						then
							
							#bTota=$(echo $bTota|awk '{$1=$1/(1024^2); print $1;}'|bc); 
							maxallowed2g=2147483648; # this is 2G from https://whatsabyte.com/P1/byteconverter.htm
							maxallowed4g=4294967296; # 4 gb
							
							if [[ $bTota -gt $maxallowed2g ]]
							then
								vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
								# Stop vpn service
								if [[ "$vpntype" == *Kodachi* ]]
								then
									SERVICE='openvpn';
									if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
									then
										notify-send -t 30000 -i $notifyIcon "Hay! You have consumed $bTotaConky of $OS_name VPN bandwidth so far 
	$OS_name VPN is shared with others please slow down so you don't get blocked!" ;
									fi
								fi
							else
							if [[ $bTota -gt $maxallowed4g ]]
							then							
								if [[ "$vpntype" == *Kodachi* ]]
								then
									SERVICE='openvpn';
									if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
									then
										notify-send -t 30000 -i $notifyIcon "Hay! You have consumed $bTotaConky of bandwidth so far 
	$OS_name VPN is shared with others please slow down so you don't get blocked!
	stopping $OS_name VPN now please use your own VPN or other free,paid choices available" ;
										echo "Novpn" > /home/$USER/.kbase/vpntype;
										sudo killall -SIGINT openvpn;
									fi
								fi
							fi
							fi	
					    fi				
										
											
					fi # if counter=24
					
				else
					echo "###Skipping net functions for now  counter is !=6 !=12 !=18 or !=24 ###";
					#echo "Auto pause" > $Mykodachi_path/healthsactionstatus;
				fi	# end counter 1 and 4 actions
					
					
				
				
				
				
				
				#If working random domain is empty which means file was empty we shoud fix it			
				if [ ! -n "$randomdomain" ]     
				then 	
					if [[ "$ipsourcefile" == 1 ]]
					then
							
						echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
						url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
						echo $url2 > $fileDomain1;
						sudo chown $LOGED_USER.$LOGED_USER $fileDomain1;
						
					else
						echo "Regular domain update ipsource=0 and we havenet setting to other";
						sudo bash $Mykodachi_path/ipcheck -a other;	
					fi							
				fi #If working random domain is empty which means file was empty we shoud fix it	
				
				
				
				# If domain file is deleted
				 
				if [[ ! -f $fileDomain1 ]];  
				then
					if [[ "$ipsourcefile" == 1 ]]
					then
							
						echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
						url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
						echo $url2 > $fileDomain1;
						sudo chown $LOGED_USER.$LOGED_USER $fileDomain1;
						
					else
						echo "Regular domain update ipsource=0 and we havenet setting to other";
						sudo bash $Mykodachi_path/ipcheck -a other;	
					fi					
				fi # If domain file is deleted
				
					
				
				
				
					
				 
			fi # end routine stuff
			

	
			
			 
			
			
			
			fileIPaddress=$(cat $Mykodachi_path/.eeds-ipinfo);
			fileTORIPaddress=$(cat $Mykodachi_path/.eeds-tipinfo);
			echo "Net Stored Kodachi IP Address: $IP_ADDR";
			echo "Net Stored Normal IP Address: $IP_ADDRPublic";
			echo "Net Stored TOR IP Address: $TIP_ADDR";
			echo "Net file Stored Kodachi IP Address: $fileIPaddress";
			echo "Net file Stored Normal IP Address: $fileIPaddress";
			echo "Net file Stored TOR IP Address: $fileTORIPaddress";
			
			
			# if we have a command from user don't sleep 
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 0 ]]
			then
						
				echo "Going to sleep we have net";
				echo "Auto pause" > $Mykodachi_path/healthsactionstatus;
				sleep 5;
				echo " finish sleeping ";
			else			
				echo "Skiped sleeping we have action";
				#theIPcounter=2;
				echo "0" > $Mykodachi_path/actionpicker;
			fi
			
			
			echo " End of net check counter is:" $theIPcounter
			if [ $theIPcounter = 24 ] ; then
				theIPcounter=0;
				echo "Reseting the counter to 0 from 24";
			fi
   
			killVPNTorcounter=0;
			 
			echo "Active" > $Mykodachi_path/netCurrentStatus;
			theIPcounter=$((theIPcounter+1))   
			
			killVPNTorcounterpopup=0;
		else ##### No NET actions####
		    echo "Not active" > $Mykodachi_path/netCurrentStatus;
			killVPNTorcounter=$((killVPNTorcounter+1))  
			echo "Net offline no ping no ip found in $fileIPaddress we found:$fileIPaddress the counter is  $killVPNTorcounter"
			netIP='digi77.com';
			echo "Replaced google with digi77.com";
			theIPcounter=0; 
			#notify-send -i $notifyIcon "Offline $killVPNTorcounter";
			
			if [[ "$ipsourcefile" == 0 ]]
			then
						
				 
				if [[ ! -f $fileDomain2 ]];  
				then					 
					cp $fileDomain1 $fileDomain2
					sudo chown $LOGED_USER.$LOGED_USER $fileDomain1;
					sudo chown $LOGED_USER.$LOGED_USER $fileDomain2;
				fi
				url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
				echo $url2 > $fileDomain1;
				
			fi
			
			# no internet
			fileIPaddress=$(cat $Mykodachi_path/.eeds-ipinfo);
			fileTORIPaddress=$(cat $Mykodachi_path/.eeds-tipinfo);
			echo "No internet now ! killing VPN"
			echo "No Net! Stored Kodachi IP Address: $IP_ADDR";
			echo "No Net! Stored Normal IP Address: $IP_ADDRPublic";
			echo "No Net! Stored TOR IP Address: $TIP_ADDR"; 
			echo "No Net! file Stored Kodachi IP Address: $fileIPaddress";
			echo "No Net! file Stored Normal IP Address: $fileIPaddress";
			echo "No Net! file Stored TOR IP Address: $fileTORIPaddress";
			if [ $killVPNTorcounter = 3 ]; then
				echo "No net trigger kill vpn and tor"
				sudo killall -SIGINT openvpn;
				autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
				if [[ "$autotornovpn" == 0 ]]
				then
					echo "check point tor stop 4";
					sudo /etc/init.d/tor stop;
					unset TIP_ADDR;
				fi
				killVPNTorcounter=0;
				#theIPcounter=2;
			fi
			
			
			killVPNTorcounterpopup=$(($killVPNTorcounterpopup+1))
			echo "Network fix popup counter: $killVPNTorcounterpopup";
			if [ $killVPNTorcounterpopup = 12 ]; then				
				
				#Maybe will use it again in future 
				#timeout 60 xfce4-terminal -e 'bash -c "sudo bash ~/.kbase/recovernetworkpopup; bash"' -T "Internet recovery"
				notify-send -i $notifyIcon "Internet connection lost you can try to recover it by going to:
Panic room menu then -> Repair Network"; 

				
			fi
		
			# if we have a command from user don't sleep 
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 0 ]]
			then
				echo "Going to sleep no Net will sleep for 5 sec only";
				echo "Auto pause" > $Mykodachi_path/healthsactionstatus;
				sleep 5;				
				echo " finish sleeping ";
			else			
				echo "Skiped sleeping we have action";
				#theIPcounter=2;
				echo "0" > $Mykodachi_path/actionpicker;
			fi		
			 
			
		fi # for net check
	

 
     
 
	# Reset conky 2 timer
	#rm -f > $Mykodachi_path/.countfile;
	actionpickervalue=0;
	echo "Auto pause" > $Mykodachi_path/healthsactionstatus;
	done	
	


fi # for hardwoknet action
